e microformats blog wiki discuss about code & tools __get started
Latest microformats news ;
What are microformats?
How to Consume Microformats 2 Data Designed for humans first a
‘and machines second,
‘A (very) belated follow up to Getting Started with Microformats 2, covering the a lan mee a cetot t
basics of consuming and using microformats 2 data. Originally posted on Bealeton ise ta
waterpigs.co.uk. built upon existing and
widely adopted standards
More and more people are using microformats 2 to mark up profiles, posts, events Learn more about microformats #®
and other data on their personal sites, enabling developers to build applications
Which use this data in useful and interesting ways. Whether you want to add basic
‘support for webmention comments to your personal site, or have ambitious plans Risener
{or a structured-data-aware-social-graph-search-engine-super-feed-reader, you're
{going to need a solid grasp of how to parse and handle microformats 2 data. (© People and Organizations
hard, XEN
Choose a Parser (@ Calendars and Events
calendar
To turn a web page containing data marked up with microformats 2 (or classic OCs Rueda
microformats, i supported) into a canonical MF2 JSON data structure, you'll need Pane
parser @ Licenses:
‘At the time of waiting, there are actively supported microformats 2 parsers pars
available forthe following programming languages: (© Tags, Keywords, Categories,
rebtag
© co @ Lists and Outines
© Javascript (server-side and browser) XOXO
© PHP More.
See the Ist ofall microformats
© Python 4 =
© Ruby
© Rust
Upcoming Events
Parsers for various other languages exist, but might not be actively supported or
‘support recent changes to the parsing specication. © See microformats events onthe wik
@ See also IndieWebCamp Events!
There are also various websites which you can use to experiment with
microformats markup without having to download a library and write any code:
(© My own live-updating php-mt2 sandbox Post Categories
(© The various parser comparison tools hosted on microformats.i0 @ Events
© Aaron Pareck'' pin13 net microformats parser for parsing either URLs @ News
or HTML fragments (@ This Week in Microformats
It there's not currently a parser avallable for your language of choice, you have a
few options:
[search blog [=|
© Call the command-tine tools provided by one of the existing libraries
from your code, and consume the JSON they provide
© Make use of one ofthe online m2 parsers capable of parsing sites, and
consume the JSON it returns (only recommended for very low volume
usage!)
© Write your own microformats 2 parser! There are plenty of people
happy to help, and a language-agnostic test suite you can plug your
implementation into for testing
Considerations During Fetching and Parsing
Most real-world microformats data is fetched from a URL, which could potentially
redirect to a different URL one or more times. The final URL in the redirect chain is
called the ‘effective URL’. HTML often contains relative URLs, which need to be
resolved against a base URL in order to be useful out of context.
It your parser has a function for ‘parsing microformats from a URL’, it should deal
with all ofthis for you. If you're making the request yourself (e.g. to use custom
caching or network settings) and then passing the response HTML and base URL
to the parser, make sure to use the effective URL, not the starting URL! The
parser will handle relative URL resolution, but it needs to know the correct base
URL.
When parsing microformats, an HTTP request which retums a non-200 value
doesn't necessarily mean that there's nothing to parse! For example, a 419
Gone response might contain a h-entry with a message explaining the deletion of
whatever was there before.
Storing Raw HTML vs Parsed Canonical JSON
vs Derived Data
When consuming microformats 2 data, you'l most often be fetching raw HTML
from a URL, parsing it to canonical JSON, then finally processing it into a simpler,
cleaned and sanitised format ready for use in your website or application. That's
three different representations of the same data — you'll most likely end up
storing the derived data somewhere for quick access, but what about the other
two?
Experience shows that, over time:
© the way a particular application cleans up mf2 data will be tweaked and
improved as you add new features and handle unexpected edge-cases
© mi2 parsers gradually get improved, fixing bugs and occasionally
‘adding entirely new features
‘Therefore, iit makes sense for your use case, | recommend archiving a copy of
the original HTML as well as your derived data, leaving out the intermediate
canonical JSON. That way, you can easily create scripts or background jobs to
update all the derived data based on the original HTML, taking advantage of both
parser improvements and improvements to your own code at the same time,
without having to re-fetch potentially hundreds of potentially broken links.
‘As mentioned in the previous section, if you archive original HTML for re-parsing,
you'll need to additionally store the effective URL for correct relative URL
resolution.
For some languages, there are already libraries (such as XRay for PHP) which
will perform common cleaning and sanitisation for you. f the assumptions with
Which these libraries are built suit your applications, you may be able to avoid a lot
of the hard work of handling raw microformats 2 data structures!
It not, read on
Navigating Microformat Structures
‘A parsed page may contain a number of microformat data structures (mf structs),
in various different places.
Take a look at the parsed canonical microformats JSON for the article you're
reading right now, for example
items is a list of top-level mf structs, each of which may contain nested mf
structs either under their proper ties or children keys
Each individual mf struct is guaranteed to have at least two keys, type and
properties. type is the primary way of identifying what sort of thing that
struct represents (e.g. a person, a post, an event). Structs can have more than
‘one type if they represent multiple things at once without wanting to nest them —
for example, a post detalling an event might be both a h-entry and a h-event at the
‘same time, Structs can also have additional top-level keys such as id and Lang,
Generally speaking, type information is most useful when dealing with top-evel
mf structs, and mf structs nested under a chi Ldren key. Nested mf structs
found in proper ties will also have type information, but their usage is usually
implied by the property name they're found under.
For many common use cases (@.g. a homepage feed and profile) there are
several different ways people might nest mf structs to achieve the same goals, so
it's important that your code is capable of searching the entire tree, rather than
Just looking at the top-level mf structs. Never assume that the microformat
struct you're looking for will be in the top-level of the i tems list! You need to
‘search the whole tree.
| recommend writing some functions which can traverse a mf tree and return all
structs which match a fitering callback. This can then be used as a basis for
writing more specific convenience functions for common tasks such as finding all
microformats on a page of a particular type, or where a certain property matches
a certain value.
See my microformats2 PHP functions for some working examples.
Possible Property Values
Each key ina mf structs properties dict maps to a lst of values for that
property. Every property may map to multiple values, and those values may be a
mixture of any of the following:
AAplain string value, containing no HTML, and leaving HTML entities unescaped
9.9
{
"items": ({
"type": ["h-card"],
"properties": {
"name": ["Barnaby Walters"]
3
H
z
(in future examples | will leave out the encapsulating {"items": [{"type":
[+++], ***}]} for brevity, focusing on the properties key of a single mt
struct)
‘An embedded HTML struct, containing two keys: htm1, which maps to an HTML
representation of the property, and va Lue, mapping to a plain text version.
"properties": {
"content": [{
"html": "<paThe content of a post, as <strong>raw HTML</strong> (or not).</p>",
"value": "The content of a post, as raw HTML (or not)."
H
z
‘An imgjalt struct, containing the URL of a parsed image under va Lue, and its alt
text under alt
"properties": {
"photo": [{
"value": "https: //example.com/profile-photo. jpg",
"alt": "Example Person"
H
z
Anested microformat data structure, with an additional va Lue key containing a
plaintext representation of the data contained within
"properties": {
"author": [{
"type": ["h-cara"],
"properties": {
"name": ["Barnaby Walters"]
h
"value": "Barnaby Walters
H
z
All properties may have more than one value. In cases where you expect a single
property value (e.g. name), simply take the frst one you find, and in cases where
‘you expect multiple values, use all values you consider valid, There are also some
cases where it may make sense to use multiple values, but to prioritise one based
‘on some heuristic — for example, an h-card may have multiple ur 1 values, in
Which case the first one is usually the “canonical” URL, and further URLs refer to
extemal profiles
Let's look at the implications of each of the potential property value structures in
turn
Firstly, Never assume that a property value will be a plaintext string,
Microformats publishers can nest microformats, embedded content and img/alt
structures in a variety of diferent ways, and your consuming code should be as
flexible as possible.
To partially make up for this complexity, you can always rely on the va lue key
of nested structs to provide you with an equivalent plaintext value,
regardless of what type of struct you've found,
When you start consuming microformats 2, write a function ike this, and get into
the habit of using it every time you want a single, plaintext value from a property:
def get_first_plaintext(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, str):
return first_val
else:
return first_val['value']
except (IndexError, KeyError):
return None
Secondly, Never assume that a particular property will contain an embedded
HTML struct — this usually applies to content, but is relevant anywhere your
application expects embedded HTML. If you want to reliably get a value encoded
‘as raw HTML, then you need to:
1. Check whether the first property value is an embedded HTML struct (Le.
has an htm key). Ifso, take the value of the ht m1 key
2. Othenwise, get the first plaintext property value using the approach above,
and HTML-escape it
3. If neither is found, the property has no value.
In Python 3.5+, that could look something ke this:
from html import escape
def get_first_ntml(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘html’ in first_val:
return first_val[‘html*]
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
plaintext_val = escape(plaintext_val)
return plaintext_val
except (IndexError, KeyError):
return None
In some cases, it may make sense for your application to be aware of whether a
value was parsed as embedded HTML or a plain text string, and to store/treat
them differently. In all other cases, always use a function ike this when you're
‘expecting embedded HTML data.
Thirdly, when expecting an image URL, check for an img/at structure, falling back
to the plain text value (and either assuming an empty alt text or inferring an
appropriate one, depending on your specific use case). Something lke this could
be a good starting point:
def get_img_alt(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘alt’ in first_val:
return first_val
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
return {'value': plaintext_val, ‘alt': '"}
return None
except (IndexError, KeyError):
return None
Finally, in cases where you expect a nested microformat, you might end up getting
‘something else. This is the hardest case to deal with, and the one which depends
the most on the specific data and use-case you're dealing with. For example, it
you're expecting a nested h-card under an author property, but get something
else, you could use any of the following approaches:
© Ityou got a plain sting which doesn't look like a URL, treat it as the
name property of an implied h-card structure with no other properties
(and if you need a URL, you could potentially take the hostname of the
effective URL, if it works in context as a useful fallback value)
© Ityou got an img at struct, you could treat the va Lue as the photo
property, the at as the name property, and potentially even take the
hostname of the photo URL to be the Implied fallback ur 1 property
(although that's pushing it abit, and in most cases i's probably better to
Just leave out the url)
© Ifyou got an embedded HTML struct, take its plaintext va Lue and use
‘one of the first two approaches
© Ifyou got a plain sting, check to see if itooks ike a URL. Ifso, fetch
that URL and look for a representative h-card to use as the author
value
© Ifyou get an embedded mf struct with a ur l property but no photo,
YyoU could fetch the ur 1, look for a representative h-card (more on that
in the next section) and see ifithhas a photo property
© Treat the author property as invalid and run the h-entry (or entire
page if relevant) through the authorship algorithm
The first three are general principles which can be applied to many scenarios
where you expect an embedded mf struct but find something else, The last three,
however, are examples of a common trend in consuming microformats 2 data: for
many common use-cases, there are well-thought-through algorithms you can use
to interpret data in a standardised way.
Know Your Algorithms and Vocabularies
The authorship algorithm mentioned above is one of several more-or-less formally
established algorithms used to solve common problems in indleweb usages of
microformats 2. Some others which are worth knowing about include:
© “Who wrote this post?": authorship algorithm
(© “There's more than one h-card on this page, which one should | use?”
representative h-card
(© “Iwant to get a paginated feed of posts from this page": How to
consume h-feed
(© “How do | find and display the main post on this page?”: How to
consume h-entry
© “Irecelved a response to one of my posts via webmention, how do |
display it?": How to display comments
Library implementations of these algorithms exist for some languages, although
they often deviate slightly from the exact text. See if you can find one which meets
your needs, and if not, write your own and share it wth the community!
In adaition to the formal consumption algorithms, i's worth looking through the
definitions of the microformats vocabularies you're using (as well as testing with
real-world data) and adding support for properties or publishing techniques you
might not have thought of the first time around. Some examples to get you
started:
© Ian h-card has no valid photo, see if there's a valid Logo you can
use instead
(© When presenting a h-entry with a featured photo, check both the
photo property and the featured property, as one or the other
might be used in different scenarios
© When dealing with address or location data (e.g. on an h-card, h-entry
or h-event), be aware that either might be present in various different
forms. Co-ordinates might be separate Latitude and Longitude
properties, a combined plaintext geo property, or an embedded h-
ge0. Addresses might be separate top-level properties or an
‘embedded h-adr. There are many variations which are totally valid to
publish, and your consuming code should be as liberal as possible in
what it accepts.
© itat-entry contains images which are marked up with u-photo within
the e-content, theyll be present both in the content htm1 key
and also under the photo property. If your app shows the embedded
content HTML rather than using the plaintext version, and also
‘supports photo properties (which may also be present outside the
content), you may have to sniff the presence of photos within the
content, and either remove them from it or ignore the corresponding
photo properties to avoid showing photos twice.
Sanitise, Validate, and Truncate
In the vast majority of cases, consuming microformats 2 data involves handling,
storing and potentially re-publishing untrusted and potentially dangerous input
data, Preventing XSS and other attacks is out of the scope of the microformats
parsing algorithm, so the data your parser gives you is just as dangerous as the
original source. You need to take your own measures for sanitising and truncating
itso you can store and display it safely.
Covering every possible injection and XSS attack is out of the scope of this article,
's0 highly recommend referring to the OWASP resources on XSS Prevention,
Unicode Attacks and Injection Attacks for more information.
Other than that, the following ideas are a good start:
© Use plaintext values where possible, only using embedded HTML when
absolutely necessary
© Pass everything (HTML or not) through a well-respected HTML
sanitizer such as PHP's HTML Purifier. Configure it to make sure that
‘embedded HTML can't interfere with your own markup or CSS. It
probably shouldn't contain any javascript ever, either.
© inany case where you're expecting a value with a specific format,
validate it as appropriate
(© More specifically, everywhere that you expect a URL, check that what
you got was actually a URL. If you're using the URL as an image,
‘consider fetching it an checking its content type
© Consider either proxying resource such as images, or storing local
copies of them (reducing size and resolution as necessary), to avoid
mixed content issues, potential attacks, and missing images ifthe links
break in the futur.
© Decide on relevant maximum length values for each separate piece of
extemal content, and truncate them as necessary. Ideally, use a
language-aware truncation algorithm to avoid breaking words apart.
When the content of a post is truncated, consider adding a "Read More”
link for convenience.
Test with Real-World Data
The web is a diverse place, and microformats are a flexible, permissive method of
marking up structured data. There are often several different yet perfectly valid
ways to achieve the same goal, and as a good consumer of mf2 data, your
application should strive to accept as many of them as possible!
‘The best way to test this is wth real world data. it your application is built with a
particular source of data in mind, then start off with testing it against that. If you
want to be able to handle a wider variety of sources, the best way Is to determine
What vocabularies and publishing use-cases your application consumes, and look
at the Examples sections of the relevant incieweb.org wiki pages for real-world
sites to test your code against.
Don't forget to test your code against examples you've published on your own
personal site!
Next Steps
Hopefully this article helped you avoid a lot of common gotchas, and gave you a
{good head:-start towards successfully consuming real-world microformats 2 data.
Ityou have questions or issues, of want to share something cool you've built,
‘come and join us in the indieweb chat room,
February 19th, 2022 | (FY waterpigs.co.ukd
Comments Off on How to Consume Microformats 2 Data
Google confirms Microformats are still a
recommended metadata format for content
This post originally appeared on Jamie Tanna’s ste
Google announced that they are removing support for the data-vocabulary
metadata markup that could be used to provide rich search results on its Search
Engine,
Ina Twitter exchange, John Mueller, a Webmaster Trends Analyst at Google,
confirmed that Microformats are stil being supported by Google at this time:
Yes, we still support them,
= 3. John Js (@JohnMu) January 24, 2020
John also confirmed that he knows of no upcoming plans to deprecate
Microformats:
We don'thave any plans for changes to announce there at the moment. dant know
off-hand how broadly microformats are used, my guess is i's much more than data
vocabulary. That sad... ips: o/ZCE7TKmPa
= 3. John Js (@JohnMu) January 24, 2020
This is an especially great result due to the way that Google is quite happy to
‘abandon various metadata formats, as noted in our 7th anniversary blog post,
‘almost 8 years ago. With this announcement, Microformats are now the longest-
‘Supported metadata format that Google parses, since at least 2009!
With the continued growth of Microformats across the IndieWeb, we expect that
Google will extend its Microformats support accordingly
Tags for this entry indieweb, microformats2
microformats.org Year 14 — Welcome New Admins
In microformats.org year 14, we welcome new admins: Aaron Parecki, Gregor
Mort, Martijn van der Ven, and Sven Knebel All have been active for years,
helping welcome new members and doing essential wiki gardening &
microformats2 parser updates!
Originally posted at: tantek.com
Tags for this entry microformats2
‘june 22nd, 2018 | {gffrancek
{Comments Off on microformats.org Year 14 — Welcome New Admins
Happy 13th to microformats.org!
With more use of microformats2, especially among the growing indieweb network
of websites, we've iterated key specs for real-world needs and are seeing more
active community members. More updates & posts coming up!
Originally posted on tantek.com.
Tags for this entry indieweb, microformats2
([Btiiex) Comments OF on Happy ao microm oc
Improving the php-mf2 parser
During the past year, the popular php-mt2 microformats parser has received quite
‘a few improvements. My site runs ProcessWire and one of the plugins for it uses
php-mt2, so I have been spending some time on it.
My own experience with microformats started when | discovered the hCard
microformat. Iwas impressed with the novelty of adding some simple HTML
Classes around contact information and having a browser extension parse it into
‘an address book. Years later, when | started to get involved in the IndieWeb
‘community, | leamed a lot more about microformats2 and they became a key
building block of my personal site.
php-mf2 is now much better at backwards-compatible parsing of microformatsi.
This is important because software should be able to consistently consume
content whether i's marked up with microformats1, microformats2, or a
‘combination. An experimental feature for parsing language attributes has also
been added. Finally, i's now using the microformats test suite. Several other
parsers use this test suite as well. This will make it easier to catch bugs and
improve all ofthe different parsers.
php-mt2 is a stable library that's ready to be installed in your software to start
‘consuming microformats.Itis currently used in Known, WordPress plugins, and
ProcessWire plugins for richer social interactions. Is also used in tools ike XRay
and microformats.io. fm looking forward to more improvements to php-mf2 in the
coming year as well as more software using it!
Original published at: hitps:/igregoriove.con/2017/06V/improving-the-php-mi2-
parser!
“dune 22nd, 2017
{Comments Of on Improving the php-mf2 parser
Browse all entries by month in the blog archive
Powered by WordPress | Hosting sponsored by Linode | No WWW.

e microformats blog wiki discuss about code & tools __get started
Latest microformats news ;
What are microformats?
How to Consume Microformats 2 Data Designed for humans first a
‘and machines second,
‘A (very) belated follow up to Getting Started with Microformats 2, covering the a lan mee a cetot t
basics of consuming and using microformats 2 data. Originally posted on Bealeton ise ta
waterpigs.co.uk. built upon existing and
widely adopted standards
More and more people are using microformats 2 to mark up profiles, posts, events Learn more about microformats #®
and other data on their personal sites, enabling developers to build applications
Which use this data in useful and interesting ways. Whether you want to add basic
‘support for webmention comments to your personal site, or have ambitious plans Risener
{or a structured-data-aware-social-graph-search-engine-super-feed-reader, you're
{going to need a solid grasp of how to parse and handle microformats 2 data. (© People and Organizations
hard, XEN
Choose a Parser (@ Calendars and Events
calendar
To turn a web page containing data marked up with microformats 2 (or classic OCs Rueda
microformats, i supported) into a canonical MF2 JSON data structure, you'll need Pane
parser @ Licenses:
‘At the time of waiting, there are actively supported microformats 2 parsers pars
available forthe following programming languages: (© Tags, Keywords, Categories,
rebtag
© co @ Lists and Outines
© Javascript (server-side and browser) XOXO
© PHP More.
See the Ist ofall microformats
© Python 4 =
© Ruby
© Rust
Upcoming Events
Parsers for various other languages exist, but might not be actively supported or
‘support recent changes to the parsing specication. © See microformats events onthe wik
@ See also IndieWebCamp Events!
There are also various websites which you can use to experiment with
microformats markup without having to download a library and write any code:
(© My own live-updating php-mt2 sandbox Post Categories
(© The various parser comparison tools hosted on microformats.i0 @ Events
© Aaron Pareck'' pin13 net microformats parser for parsing either URLs @ News
or HTML fragments (@ This Week in Microformats
It there's not currently a parser avallable for your language of choice, you have a
few options:
[search blog [=|
© Call the command-tine tools provided by one of the existing libraries
from your code, and consume the JSON they provide
© Make use of one ofthe online m2 parsers capable of parsing sites, and
consume the JSON it returns (only recommended for very low volume
usage!)
© Write your own microformats 2 parser! There are plenty of people
happy to help, and a language-agnostic test suite you can plug your
implementation into for testing
Considerations During Fetching and Parsing
Most real-world microformats data is fetched from a URL, which could potentially
redirect to a different URL one or more times. The final URL in the redirect chain is
called the ‘effective URL’. HTML often contains relative URLs, which need to be
resolved against a base URL in order to be useful out of context.
It your parser has a function for ‘parsing microformats from a URL’, it should deal
with all ofthis for you. If you're making the request yourself (e.g. to use custom
caching or network settings) and then passing the response HTML and base URL
to the parser, make sure to use the effective URL, not the starting URL! The
parser will handle relative URL resolution, but it needs to know the correct base
URL.
When parsing microformats, an HTTP request which retums a non-200 value
doesn't necessarily mean that there's nothing to parse! For example, a 419
Gone response might contain a h-entry with a message explaining the deletion of
whatever was there before.
Storing Raw HTML vs Parsed Canonical JSON
vs Derived Data
When consuming microformats 2 data, you'l most often be fetching raw HTML
from a URL, parsing it to canonical JSON, then finally processing it into a simpler,
cleaned and sanitised format ready for use in your website or application. That's
three different representations of the same data — you'll most likely end up
storing the derived data somewhere for quick access, but what about the other
two?
Experience shows that, over time:
© the way a particular application cleans up mf2 data will be tweaked and
improved as you add new features and handle unexpected edge-cases
© mi2 parsers gradually get improved, fixing bugs and occasionally
‘adding entirely new features
‘Therefore, iit makes sense for your use case, | recommend archiving a copy of
the original HTML as well as your derived data, leaving out the intermediate
canonical JSON. That way, you can easily create scripts or background jobs to
update all the derived data based on the original HTML, taking advantage of both
parser improvements and improvements to your own code at the same time,
without having to re-fetch potentially hundreds of potentially broken links.
‘As mentioned in the previous section, if you archive original HTML for re-parsing,
you'll need to additionally store the effective URL for correct relative URL
resolution.
For some languages, there are already libraries (such as XRay for PHP) which
will perform common cleaning and sanitisation for you. f the assumptions with
Which these libraries are built suit your applications, you may be able to avoid a lot
of the hard work of handling raw microformats 2 data structures!
It not, read on
Navigating Microformat Structures
‘A parsed page may contain a number of microformat data structures (mf structs),
in various different places.
Take a look at the parsed canonical microformats JSON for the article you're
reading right now, for example
items is a list of top-level mf structs, each of which may contain nested mf
structs either under their proper ties or children keys
Each individual mf struct is guaranteed to have at least two keys, type and
properties. type is the primary way of identifying what sort of thing that
struct represents (e.g. a person, a post, an event). Structs can have more than
‘one type if they represent multiple things at once without wanting to nest them —
for example, a post detalling an event might be both a h-entry and a h-event at the
‘same time, Structs can also have additional top-level keys such as id and Lang,
Generally speaking, type information is most useful when dealing with top-evel
mf structs, and mf structs nested under a chi Ldren key. Nested mf structs
found in proper ties will also have type information, but their usage is usually
implied by the property name they're found under.
For many common use cases (@.g. a homepage feed and profile) there are
several different ways people might nest mf structs to achieve the same goals, so
it's important that your code is capable of searching the entire tree, rather than
Just looking at the top-level mf structs. Never assume that the microformat
struct you're looking for will be in the top-level of the i tems list! You need to
‘search the whole tree.
| recommend writing some functions which can traverse a mf tree and return all
structs which match a fitering callback. This can then be used as a basis for
writing more specific convenience functions for common tasks such as finding all
microformats on a page of a particular type, or where a certain property matches
a certain value.
See my microformats2 PHP functions for some working examples.
Possible Property Values
Each key ina mf structs properties dict maps to a lst of values for that
property. Every property may map to multiple values, and those values may be a
mixture of any of the following:
AAplain string value, containing no HTML, and leaving HTML entities unescaped
9.9
{
"items": ({
"type": ["h-card"],
"properties": {
"name": ["Barnaby Walters"]
3
H
z
(in future examples | will leave out the encapsulating {"items": [{"type":
[+++], ***}]} for brevity, focusing on the properties key of a single mt
struct)
‘An embedded HTML struct, containing two keys: htm1, which maps to an HTML
representation of the property, and va Lue, mapping to a plain text version.
"properties": {
"content": [{
"html": "<paThe content of a post, as <strong>raw HTML</strong> (or not).</p>",
"value": "The content of a post, as raw HTML (or not)."
H
z
‘An imgjalt struct, containing the URL of a parsed image under va Lue, and its alt
text under alt
"properties": {
"photo": [{
"value": "https: //example.com/profile-photo. jpg",
"alt": "Example Person"
H
z
Anested microformat data structure, with an additional va Lue key containing a
plaintext representation of the data contained within
"properties": {
"author": [{
"type": ["h-cara"],
"properties": {
"name": ["Barnaby Walters"]
h
"value": "Barnaby Walters
H
z
All properties may have more than one value. In cases where you expect a single
property value (e.g. name), simply take the frst one you find, and in cases where
‘you expect multiple values, use all values you consider valid, There are also some
cases where it may make sense to use multiple values, but to prioritise one based
‘on some heuristic — for example, an h-card may have multiple ur 1 values, in
Which case the first one is usually the “canonical” URL, and further URLs refer to
extemal profiles
Let's look at the implications of each of the potential property value structures in
turn
Firstly, Never assume that a property value will be a plaintext string,
Microformats publishers can nest microformats, embedded content and img/alt
structures in a variety of diferent ways, and your consuming code should be as
flexible as possible.
To partially make up for this complexity, you can always rely on the va lue key
of nested structs to provide you with an equivalent plaintext value,
regardless of what type of struct you've found,
When you start consuming microformats 2, write a function ike this, and get into
the habit of using it every time you want a single, plaintext value from a property:
def get_first_plaintext(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, str):
return first_val
else:
return first_val['value']
except (IndexError, KeyError):
return None
Secondly, Never assume that a particular property will contain an embedded
HTML struct — this usually applies to content, but is relevant anywhere your
application expects embedded HTML. If you want to reliably get a value encoded
‘as raw HTML, then you need to:
1. Check whether the first property value is an embedded HTML struct (Le.
has an htm key). Ifso, take the value of the ht m1 key
2. Othenwise, get the first plaintext property value using the approach above,
and HTML-escape it
3. If neither is found, the property has no value.
In Python 3.5+, that could look something ke this:
from html import escape
def get_first_ntml(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘html’ in first_val:
return first_val[‘html*]
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
plaintext_val = escape(plaintext_val)
return plaintext_val
except (IndexError, KeyError):
return None
In some cases, it may make sense for your application to be aware of whether a
value was parsed as embedded HTML or a plain text string, and to store/treat
them differently. In all other cases, always use a function ike this when you're
‘expecting embedded HTML data.
Thirdly, when expecting an image URL, check for an img/at structure, falling back
to the plain text value (and either assuming an empty alt text or inferring an
appropriate one, depending on your specific use case). Something lke this could
be a good starting point:
def get_img_alt(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘alt’ in first_val:
return first_val
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
return {'value': plaintext_val, ‘alt': '"}
return None
except (IndexError, KeyError):
return None
Finally, in cases where you expect a nested microformat, you might end up getting
‘something else. This is the hardest case to deal with, and the one which depends
the most on the specific data and use-case you're dealing with. For example, it
you're expecting a nested h-card under an author property, but get something
else, you could use any of the following approaches:
© Ityou got a plain sting which doesn't look like a URL, treat it as the
name property of an implied h-card structure with no other properties
(and if you need a URL, you could potentially take the hostname of the
effective URL, if it works in context as a useful fallback value)
© Ityou got an img at struct, you could treat the va Lue as the photo
property, the at as the name property, and potentially even take the
hostname of the photo URL to be the Implied fallback ur 1 property
(although that's pushing it abit, and in most cases i's probably better to
Just leave out the url)
© Ifyou got an embedded HTML struct, take its plaintext va Lue and use
‘one of the first two approaches
© Ifyou got a plain sting, check to see if itooks ike a URL. Ifso, fetch
that URL and look for a representative h-card to use as the author
value
© Ifyou get an embedded mf struct with a ur l property but no photo,
YyoU could fetch the ur 1, look for a representative h-card (more on that
in the next section) and see ifithhas a photo property
© Treat the author property as invalid and run the h-entry (or entire
page if relevant) through the authorship algorithm
The first three are general principles which can be applied to many scenarios
where you expect an embedded mf struct but find something else, The last three,
however, are examples of a common trend in consuming microformats 2 data: for
many common use-cases, there are well-thought-through algorithms you can use
to interpret data in a standardised way.
Know Your Algorithms and Vocabularies
The authorship algorithm mentioned above is one of several more-or-less formally
established algorithms used to solve common problems in indleweb usages of
microformats 2. Some others which are worth knowing about include:
© “Who wrote this post?": authorship algorithm
(© “There's more than one h-card on this page, which one should | use?”
representative h-card
(© “Iwant to get a paginated feed of posts from this page": How to
consume h-feed
(© “How do | find and display the main post on this page?”: How to
consume h-entry
© “Irecelved a response to one of my posts via webmention, how do |
display it?": How to display comments
Library implementations of these algorithms exist for some languages, although
they often deviate slightly from the exact text. See if you can find one which meets
your needs, and if not, write your own and share it wth the community!
In adaition to the formal consumption algorithms, i's worth looking through the
definitions of the microformats vocabularies you're using (as well as testing with
real-world data) and adding support for properties or publishing techniques you
might not have thought of the first time around. Some examples to get you
started:
© Ian h-card has no valid photo, see if there's a valid Logo you can
use instead
(© When presenting a h-entry with a featured photo, check both the
photo property and the featured property, as one or the other
might be used in different scenarios
© When dealing with address or location data (e.g. on an h-card, h-entry
or h-event), be aware that either might be present in various different
forms. Co-ordinates might be separate Latitude and Longitude
properties, a combined plaintext geo property, or an embedded h-
ge0. Addresses might be separate top-level properties or an
‘embedded h-adr. There are many variations which are totally valid to
publish, and your consuming code should be as liberal as possible in
what it accepts.
© itat-entry contains images which are marked up with u-photo within
the e-content, theyll be present both in the content htm1 key
and also under the photo property. If your app shows the embedded
content HTML rather than using the plaintext version, and also
‘supports photo properties (which may also be present outside the
content), you may have to sniff the presence of photos within the
content, and either remove them from it or ignore the corresponding
photo properties to avoid showing photos twice.
Sanitise, Validate, and Truncate
In the vast majority of cases, consuming microformats 2 data involves handling,
storing and potentially re-publishing untrusted and potentially dangerous input
data, Preventing XSS and other attacks is out of the scope of the microformats
parsing algorithm, so the data your parser gives you is just as dangerous as the
original source. You need to take your own measures for sanitising and truncating
itso you can store and display it safely.
Covering every possible injection and XSS attack is out of the scope of this article,
's0 highly recommend referring to the OWASP resources on XSS Prevention,
Unicode Attacks and Injection Attacks for more information.
Other than that, the following ideas are a good start:
© Use plaintext values where possible, only using embedded HTML when
absolutely necessary
© Pass everything (HTML or not) through a well-respected HTML
sanitizer such as PHP's HTML Purifier. Configure it to make sure that
‘embedded HTML can't interfere with your own markup or CSS. It
probably shouldn't contain any javascript ever, either.
© inany case where you're expecting a value with a specific format,
validate it as appropriate
(© More specifically, everywhere that you expect a URL, check that what
you got was actually a URL. If you're using the URL as an image,
‘consider fetching it an checking its content type
© Consider either proxying resource such as images, or storing local
copies of them (reducing size and resolution as necessary), to avoid
mixed content issues, potential attacks, and missing images ifthe links
break in the futur.
© Decide on relevant maximum length values for each separate piece of
extemal content, and truncate them as necessary. Ideally, use a
language-aware truncation algorithm to avoid breaking words apart.
When the content of a post is truncated, consider adding a "Read More”
link for convenience.
Test with Real-World Data
The web is a diverse place, and microformats are a flexible, permissive method of
marking up structured data. There are often several different yet perfectly valid
ways to achieve the same goal, and as a good consumer of mf2 data, your
application should strive to accept as many of them as possible!
‘The best way to test this is wth real world data. it your application is built with a
particular source of data in mind, then start off with testing it against that. If you
want to be able to handle a wider variety of sources, the best way Is to determine
What vocabularies and publishing use-cases your application consumes, and look
at the Examples sections of the relevant incieweb.org wiki pages for real-world
sites to test your code against.
Don't forget to test your code against examples you've published on your own
personal site!
Next Steps
Hopefully this article helped you avoid a lot of common gotchas, and gave you a
{good head:-start towards successfully consuming real-world microformats 2 data.
Ityou have questions or issues, of want to share something cool you've built,
‘come and join us in the indieweb chat room,
February 19th, 2022 | (FY waterpigs.co.ukd
Comments Off on How to Consume Microformats 2 Data
Google confirms Microformats are still a
recommended metadata format for content
This post originally appeared on Jamie Tanna’s ste
Google announced that they are removing support for the data-vocabulary
metadata markup that could be used to provide rich search results on its Search
Engine,
Ina Twitter exchange, John Mueller, a Webmaster Trends Analyst at Google,
confirmed that Microformats are stil being supported by Google at this time:
Yes, we still support them,
= 3. John Js (@JohnMu) January 24, 2020
John also confirmed that he knows of no upcoming plans to deprecate
Microformats:
We don'thave any plans for changes to announce there at the moment. dant know
off-hand how broadly microformats are used, my guess is i's much more than data
vocabulary. That sad... ips: o/ZCE7TKmPa
= 3. John Js (@JohnMu) January 24, 2020
This is an especially great result due to the way that Google is quite happy to
‘abandon various metadata formats, as noted in our 7th anniversary blog post,
‘almost 8 years ago. With this announcement, Microformats are now the longest-
‘Supported metadata format that Google parses, since at least 2009!
With the continued growth of Microformats across the IndieWeb, we expect that
Google will extend its Microformats support accordingly
Tags for this entry indieweb, microformats2
microformats.org Year 14 — Welcome New Admins
In microformats.org year 14, we welcome new admins: Aaron Parecki, Gregor
Mort, Martijn van der Ven, and Sven Knebel All have been active for years,
helping welcome new members and doing essential wiki gardening &
microformats2 parser updates!
Originally posted at: tantek.com
Tags for this entry microformats2
‘june 22nd, 2018 | {gffrancek
{Comments Off on microformats.org Year 14 — Welcome New Admins
Happy 13th to microformats.org!
With more use of microformats2, especially among the growing indieweb network
of websites, we've iterated key specs for real-world needs and are seeing more
active community members. More updates & posts coming up!
Originally posted on tantek.com.
Tags for this entry indieweb, microformats2
([Btiiex) Comments OF on Happy ao microm oc
Improving the php-mf2 parser
During the past year, the popular php-mt2 microformats parser has received quite
‘a few improvements. My site runs ProcessWire and one of the plugins for it uses
php-mt2, so I have been spending some time on it.
My own experience with microformats started when | discovered the hCard
microformat. Iwas impressed with the novelty of adding some simple HTML
Classes around contact information and having a browser extension parse it into
‘an address book. Years later, when | started to get involved in the IndieWeb
‘community, | leamed a lot more about microformats2 and they became a key
building block of my personal site.
php-mf2 is now much better at backwards-compatible parsing of microformatsi.
This is important because software should be able to consistently consume
content whether i's marked up with microformats1, microformats2, or a
‘combination. An experimental feature for parsing language attributes has also
been added. Finally, i's now using the microformats test suite. Several other
parsers use this test suite as well. This will make it easier to catch bugs and
improve all ofthe different parsers.
php-mt2 is a stable library that's ready to be installed in your software to start
‘consuming microformats.Itis currently used in Known, WordPress plugins, and
ProcessWire plugins for richer social interactions. Is also used in tools ike XRay
and microformats.io. fm looking forward to more improvements to php-mf2 in the
coming year as well as more software using it!
Original published at: hitps:/igregoriove.con/2017/06V/improving-the-php-mi2-
parser!
“dune 22nd, 2017
{Comments Of on Improving the php-mf2 parser
Browse all entries by month in the blog archive
Powered by WordPress | Hosting sponsored by Linode | No WWW.

e microformats blog wiki discuss about code & tools __get started
Latest microformats news ;
What are microformats?
How to Consume Microformats 2 Data Designed for humans first a
‘and machines second,
‘A (very) belated follow up to Getting Started with Microformats 2, covering the a lan mee a cetot t
basics of consuming and using microformats 2 data. Originally posted on Bealeton ise ta
waterpigs.co.uk. built upon existing and
widely adopted standards
More and more people are using microformats 2 to mark up profiles, posts, events Learn more about microformats #®
and other data on their personal sites, enabling developers to build applications
Which use this data in useful and interesting ways. Whether you want to add basic
‘support for webmention comments to your personal site, or have ambitious plans Risener
{or a structured-data-aware-social-graph-search-engine-super-feed-reader, you're
{going to need a solid grasp of how to parse and handle microformats 2 data. (© People and Organizations
hard, XEN
Choose a Parser (@ Calendars and Events
calendar
To turn a web page containing data marked up with microformats 2 (or classic OCs Rueda
microformats, i supported) into a canonical MF2 JSON data structure, you'll need Pane
parser @ Licenses:
‘At the time of waiting, there are actively supported microformats 2 parsers pars
available forthe following programming languages: (© Tags, Keywords, Categories,
rebtag
© co @ Lists and Outines
© Javascript (server-side and browser) XOXO
© PHP More.
See the Ist ofall microformats
© Python 4 =
© Ruby
© Rust
Upcoming Events
Parsers for various other languages exist, but might not be actively supported or
‘support recent changes to the parsing specication. © See microformats events onthe wik
@ See also IndieWebCamp Events!
There are also various websites which you can use to experiment with
microformats markup without having to download a library and write any code:
(© My own live-updating php-mt2 sandbox Post Categories
(© The various parser comparison tools hosted on microformats.i0 @ Events
© Aaron Pareck'' pin13 net microformats parser for parsing either URLs @ News
or HTML fragments (@ This Week in Microformats
It there's not currently a parser avallable for your language of choice, you have a
few options:
[search blog [=|
© Call the command-tine tools provided by one of the existing libraries
from your code, and consume the JSON they provide
© Make use of one ofthe online m2 parsers capable of parsing sites, and
consume the JSON it returns (only recommended for very low volume
usage!)
© Write your own microformats 2 parser! There are plenty of people
happy to help, and a language-agnostic test suite you can plug your
implementation into for testing
Considerations During Fetching and Parsing
Most real-world microformats data is fetched from a URL, which could potentially
redirect to a different URL one or more times. The final URL in the redirect chain is
called the ‘effective URL’. HTML often contains relative URLs, which need to be
resolved against a base URL in order to be useful out of context.
It your parser has a function for ‘parsing microformats from a URL’, it should deal
with all ofthis for you. If you're making the request yourself (e.g. to use custom
caching or network settings) and then passing the response HTML and base URL
to the parser, make sure to use the effective URL, not the starting URL! The
parser will handle relative URL resolution, but it needs to know the correct base
URL.
When parsing microformats, an HTTP request which retums a non-200 value
doesn't necessarily mean that there's nothing to parse! For example, a 419
Gone response might contain a h-entry with a message explaining the deletion of
whatever was there before.
Storing Raw HTML vs Parsed Canonical JSON
vs Derived Data
When consuming microformats 2 data, you'l most often be fetching raw HTML
from a URL, parsing it to canonical JSON, then finally processing it into a simpler,
cleaned and sanitised format ready for use in your website or application. That's
three different representations of the same data — you'll most likely end up
storing the derived data somewhere for quick access, but what about the other
two?
Experience shows that, over time:
© the way a particular application cleans up mf2 data will be tweaked and
improved as you add new features and handle unexpected edge-cases
© mi2 parsers gradually get improved, fixing bugs and occasionally
‘adding entirely new features
‘Therefore, iit makes sense for your use case, | recommend archiving a copy of
the original HTML as well as your derived data, leaving out the intermediate
canonical JSON. That way, you can easily create scripts or background jobs to
update all the derived data based on the original HTML, taking advantage of both
parser improvements and improvements to your own code at the same time,
without having to re-fetch potentially hundreds of potentially broken links.
‘As mentioned in the previous section, if you archive original HTML for re-parsing,
you'll need to additionally store the effective URL for correct relative URL
resolution.
For some languages, there are already libraries (such as XRay for PHP) which
will perform common cleaning and sanitisation for you. f the assumptions with
Which these libraries are built suit your applications, you may be able to avoid a lot
of the hard work of handling raw microformats 2 data structures!
It not, read on
Navigating Microformat Structures
‘A parsed page may contain a number of microformat data structures (mf structs),
in various different places.
Take a look at the parsed canonical microformats JSON for the article you're
reading right now, for example
items is a list of top-level mf structs, each of which may contain nested mf
structs either under their proper ties or children keys
Each individual mf struct is guaranteed to have at least two keys, type and
properties. type is the primary way of identifying what sort of thing that
struct represents (e.g. a person, a post, an event). Structs can have more than
‘one type if they represent multiple things at once without wanting to nest them —
for example, a post detalling an event might be both a h-entry and a h-event at the
‘same time, Structs can also have additional top-level keys such as id and Lang,
Generally speaking, type information is most useful when dealing with top-evel
mf structs, and mf structs nested under a chi Ldren key. Nested mf structs
found in proper ties will also have type information, but their usage is usually
implied by the property name they're found under.
For many common use cases (@.g. a homepage feed and profile) there are
several different ways people might nest mf structs to achieve the same goals, so
it's important that your code is capable of searching the entire tree, rather than
Just looking at the top-level mf structs. Never assume that the microformat
struct you're looking for will be in the top-level of the i tems list! You need to
‘search the whole tree.
| recommend writing some functions which can traverse a mf tree and return all
structs which match a fitering callback. This can then be used as a basis for
writing more specific convenience functions for common tasks such as finding all
microformats on a page of a particular type, or where a certain property matches
a certain value.
See my microformats2 PHP functions for some working examples.
Possible Property Values
Each key ina mf structs properties dict maps to a lst of values for that
property. Every property may map to multiple values, and those values may be a
mixture of any of the following:
AAplain string value, containing no HTML, and leaving HTML entities unescaped
9.9
{
"items": ({
"type": ["h-card"],
"properties": {
"name": ["Barnaby Walters"]
3
H
z
(in future examples | will leave out the encapsulating {"items": [{"type":
[+++], ***}]} for brevity, focusing on the properties key of a single mt
struct)
‘An embedded HTML struct, containing two keys: htm1, which maps to an HTML
representation of the property, and va Lue, mapping to a plain text version.
"properties": {
"content": [{
"html": "<paThe content of a post, as <strong>raw HTML</strong> (or not).</p>",
"value": "The content of a post, as raw HTML (or not)."
H
z
‘An imgjalt struct, containing the URL of a parsed image under va Lue, and its alt
text under alt
"properties": {
"photo": [{
"value": "https: //example.com/profile-photo. jpg",
"alt": "Example Person"
H
z
Anested microformat data structure, with an additional va Lue key containing a
plaintext representation of the data contained within
"properties": {
"author": [{
"type": ["h-cara"],
"properties": {
"name": ["Barnaby Walters"]
h
"value": "Barnaby Walters
H
z
All properties may have more than one value. In cases where you expect a single
property value (e.g. name), simply take the frst one you find, and in cases where
‘you expect multiple values, use all values you consider valid, There are also some
cases where it may make sense to use multiple values, but to prioritise one based
‘on some heuristic — for example, an h-card may have multiple ur 1 values, in
Which case the first one is usually the “canonical” URL, and further URLs refer to
extemal profiles
Let's look at the implications of each of the potential property value structures in
turn
Firstly, Never assume that a property value will be a plaintext string,
Microformats publishers can nest microformats, embedded content and img/alt
structures in a variety of diferent ways, and your consuming code should be as
flexible as possible.
To partially make up for this complexity, you can always rely on the va lue key
of nested structs to provide you with an equivalent plaintext value,
regardless of what type of struct you've found,
When you start consuming microformats 2, write a function ike this, and get into
the habit of using it every time you want a single, plaintext value from a property:
def get_first_plaintext(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, str):
return first_val
else:
return first_val['value']
except (IndexError, KeyError):
return None
Secondly, Never assume that a particular property will contain an embedded
HTML struct — this usually applies to content, but is relevant anywhere your
application expects embedded HTML. If you want to reliably get a value encoded
‘as raw HTML, then you need to:
1. Check whether the first property value is an embedded HTML struct (Le.
has an htm key). Ifso, take the value of the ht m1 key
2. Othenwise, get the first plaintext property value using the approach above,
and HTML-escape it
3. If neither is found, the property has no value.
In Python 3.5+, that could look something ke this:
from html import escape
def get_first_ntml(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘html’ in first_val:
return first_val[‘html*]
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
plaintext_val = escape(plaintext_val)
return plaintext_val
except (IndexError, KeyError):
return None
In some cases, it may make sense for your application to be aware of whether a
value was parsed as embedded HTML or a plain text string, and to store/treat
them differently. In all other cases, always use a function ike this when you're
‘expecting embedded HTML data.
Thirdly, when expecting an image URL, check for an img/at structure, falling back
to the plain text value (and either assuming an empty alt text or inferring an
appropriate one, depending on your specific use case). Something lke this could
be a good starting point:
def get_img_alt(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘alt’ in first_val:
return first_val
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
return {'value': plaintext_val, ‘alt': '"}
return None
except (IndexError, KeyError):
return None
Finally, in cases where you expect a nested microformat, you might end up getting
‘something else. This is the hardest case to deal with, and the one which depends
the most on the specific data and use-case you're dealing with. For example, it
you're expecting a nested h-card under an author property, but get something
else, you could use any of the following approaches:
© Ityou got a plain sting which doesn't look like a URL, treat it as the
name property of an implied h-card structure with no other properties
(and if you need a URL, you could potentially take the hostname of the
effective URL, if it works in context as a useful fallback value)
© Ityou got an img at struct, you could treat the va Lue as the photo
property, the at as the name property, and potentially even take the
hostname of the photo URL to be the Implied fallback ur 1 property
(although that's pushing it abit, and in most cases i's probably better to
Just leave out the url)
© Ifyou got an embedded HTML struct, take its plaintext va Lue and use
‘one of the first two approaches
© Ifyou got a plain sting, check to see if itooks ike a URL. Ifso, fetch
that URL and look for a representative h-card to use as the author
value
© Ifyou get an embedded mf struct with a ur l property but no photo,
YyoU could fetch the ur 1, look for a representative h-card (more on that
in the next section) and see ifithhas a photo property
© Treat the author property as invalid and run the h-entry (or entire
page if relevant) through the authorship algorithm
The first three are general principles which can be applied to many scenarios
where you expect an embedded mf struct but find something else, The last three,
however, are examples of a common trend in consuming microformats 2 data: for
many common use-cases, there are well-thought-through algorithms you can use
to interpret data in a standardised way.
Know Your Algorithms and Vocabularies
The authorship algorithm mentioned above is one of several more-or-less formally
established algorithms used to solve common problems in indleweb usages of
microformats 2. Some others which are worth knowing about include:
© “Who wrote this post?": authorship algorithm
(© “There's more than one h-card on this page, which one should | use?”
representative h-card
(© “Iwant to get a paginated feed of posts from this page": How to
consume h-feed
(© “How do | find and display the main post on this page?”: How to
consume h-entry
© “Irecelved a response to one of my posts via webmention, how do |
display it?": How to display comments
Library implementations of these algorithms exist for some languages, although
they often deviate slightly from the exact text. See if you can find one which meets
your needs, and if not, write your own and share it wth the community!
In adaition to the formal consumption algorithms, i's worth looking through the
definitions of the microformats vocabularies you're using (as well as testing with
real-world data) and adding support for properties or publishing techniques you
might not have thought of the first time around. Some examples to get you
started:
© Ian h-card has no valid photo, see if there's a valid Logo you can
use instead
(© When presenting a h-entry with a featured photo, check both the
photo property and the featured property, as one or the other
might be used in different scenarios
© When dealing with address or location data (e.g. on an h-card, h-entry
or h-event), be aware that either might be present in various different
forms. Co-ordinates might be separate Latitude and Longitude
properties, a combined plaintext geo property, or an embedded h-
ge0. Addresses might be separate top-level properties or an
‘embedded h-adr. There are many variations which are totally valid to
publish, and your consuming code should be as liberal as possible in
what it accepts.
© itat-entry contains images which are marked up with u-photo within
the e-content, theyll be present both in the content htm1 key
and also under the photo property. If your app shows the embedded
content HTML rather than using the plaintext version, and also
‘supports photo properties (which may also be present outside the
content), you may have to sniff the presence of photos within the
content, and either remove them from it or ignore the corresponding
photo properties to avoid showing photos twice.
Sanitise, Validate, and Truncate
In the vast majority of cases, consuming microformats 2 data involves handling,
storing and potentially re-publishing untrusted and potentially dangerous input
data, Preventing XSS and other attacks is out of the scope of the microformats
parsing algorithm, so the data your parser gives you is just as dangerous as the
original source. You need to take your own measures for sanitising and truncating
itso you can store and display it safely.
Covering every possible injection and XSS attack is out of the scope of this article,
's0 highly recommend referring to the OWASP resources on XSS Prevention,
Unicode Attacks and Injection Attacks for more information.
Other than that, the following ideas are a good start:
© Use plaintext values where possible, only using embedded HTML when
absolutely necessary
© Pass everything (HTML or not) through a well-respected HTML
sanitizer such as PHP's HTML Purifier. Configure it to make sure that
‘embedded HTML can't interfere with your own markup or CSS. It
probably shouldn't contain any javascript ever, either.
© inany case where you're expecting a value with a specific format,
validate it as appropriate
(© More specifically, everywhere that you expect a URL, check that what
you got was actually a URL. If you're using the URL as an image,
‘consider fetching it an checking its content type
© Consider either proxying resource such as images, or storing local
copies of them (reducing size and resolution as necessary), to avoid
mixed content issues, potential attacks, and missing images ifthe links
break in the futur.
© Decide on relevant maximum length values for each separate piece of
extemal content, and truncate them as necessary. Ideally, use a
language-aware truncation algorithm to avoid breaking words apart.
When the content of a post is truncated, consider adding a "Read More”
link for convenience.
Test with Real-World Data
The web is a diverse place, and microformats are a flexible, permissive method of
marking up structured data. There are often several different yet perfectly valid
ways to achieve the same goal, and as a good consumer of mf2 data, your
application should strive to accept as many of them as possible!
‘The best way to test this is wth real world data. it your application is built with a
particular source of data in mind, then start off with testing it against that. If you
want to be able to handle a wider variety of sources, the best way Is to determine
What vocabularies and publishing use-cases your application consumes, and look
at the Examples sections of the relevant incieweb.org wiki pages for real-world
sites to test your code against.
Don't forget to test your code against examples you've published on your own
personal site!
Next Steps
Hopefully this article helped you avoid a lot of common gotchas, and gave you a
{good head:-start towards successfully consuming real-world microformats 2 data.
Ityou have questions or issues, of want to share something cool you've built,
‘come and join us in the indieweb chat room,
February 19th, 2022 | (FY waterpigs.co.ukd
Comments Off on How to Consume Microformats 2 Data
Google confirms Microformats are still a
recommended metadata format for content
This post originally appeared on Jamie Tanna’s ste
Google announced that they are removing support for the data-vocabulary
metadata markup that could be used to provide rich search results on its Search
Engine,
Ina Twitter exchange, John Mueller, a Webmaster Trends Analyst at Google,
confirmed that Microformats are stil being supported by Google at this time:
Yes, we still support them,
= 3. John Js (@JohnMu) January 24, 2020
John also confirmed that he knows of no upcoming plans to deprecate
Microformats:
We don'thave any plans for changes to announce there at the moment. dant know
off-hand how broadly microformats are used, my guess is i's much more than data
vocabulary. That sad... ips: o/ZCE7TKmPa
= 3. John Js (@JohnMu) January 24, 2020
This is an especially great result due to the way that Google is quite happy to
‘abandon various metadata formats, as noted in our 7th anniversary blog post,
‘almost 8 years ago. With this announcement, Microformats are now the longest-
‘Supported metadata format that Google parses, since at least 2009!
With the continued growth of Microformats across the IndieWeb, we expect that
Google will extend its Microformats support accordingly
Tags for this entry indieweb, microformats2
microformats.org Year 14 — Welcome New Admins
In microformats.org year 14, we welcome new admins: Aaron Parecki, Gregor
Mort, Martijn van der Ven, and Sven Knebel All have been active for years,
helping welcome new members and doing essential wiki gardening &
microformats2 parser updates!
Originally posted at: tantek.com
Tags for this entry microformats2
‘june 22nd, 2018 | {gffrancek
{Comments Off on microformats.org Year 14 — Welcome New Admins
Happy 13th to microformats.org!
With more use of microformats2, especially among the growing indieweb network
of websites, we've iterated key specs for real-world needs and are seeing more
active community members. More updates & posts coming up!
Originally posted on tantek.com.
Tags for this entry indieweb, microformats2
([Btiiex) Comments OF on Happy ao microm oc
Improving the php-mf2 parser
During the past year, the popular php-mt2 microformats parser has received quite
‘a few improvements. My site runs ProcessWire and one of the plugins for it uses
php-mt2, so I have been spending some time on it.
My own experience with microformats started when | discovered the hCard
microformat. Iwas impressed with the novelty of adding some simple HTML
Classes around contact information and having a browser extension parse it into
‘an address book. Years later, when | started to get involved in the IndieWeb
‘community, | leamed a lot more about microformats2 and they became a key
building block of my personal site.
php-mf2 is now much better at backwards-compatible parsing of microformatsi.
This is important because software should be able to consistently consume
content whether i's marked up with microformats1, microformats2, or a
‘combination. An experimental feature for parsing language attributes has also
been added. Finally, i's now using the microformats test suite. Several other
parsers use this test suite as well. This will make it easier to catch bugs and
improve all ofthe different parsers.
php-mt2 is a stable library that's ready to be installed in your software to start
‘consuming microformats.Itis currently used in Known, WordPress plugins, and
ProcessWire plugins for richer social interactions. Is also used in tools ike XRay
and microformats.io. fm looking forward to more improvements to php-mf2 in the
coming year as well as more software using it!
Original published at: hitps:/igregoriove.con/2017/06V/improving-the-php-mi2-
parser!
“dune 22nd, 2017
{Comments Of on Improving the php-mf2 parser
Browse all entries by month in the blog archive
Powered by WordPress | Hosting sponsored by Linode | No WWW.

e microformats blog wiki discuss about code & tools __get started
Latest microformats news ;
What are microformats?
How to Consume Microformats 2 Data Designed for humans first a
‘and machines second,
‘A (very) belated follow up to Getting Started with Microformats 2, covering the a lan mee a cetot t
basics of consuming and using microformats 2 data. Originally posted on Bealeton ise ta
waterpigs.co.uk. built upon existing and
widely adopted standards
More and more people are using microformats 2 to mark up profiles, posts, events Learn more about microformats #®
and other data on their personal sites, enabling developers to build applications
Which use this data in useful and interesting ways. Whether you want to add basic
‘support for webmention comments to your personal site, or have ambitious plans Risener
{or a structured-data-aware-social-graph-search-engine-super-feed-reader, you're
{going to need a solid grasp of how to parse and handle microformats 2 data. (© People and Organizations
hard, XEN
Choose a Parser (@ Calendars and Events
calendar
To turn a web page containing data marked up with microformats 2 (or classic OCs Rueda
microformats, i supported) into a canonical MF2 JSON data structure, you'll need Pane
parser @ Licenses:
‘At the time of waiting, there are actively supported microformats 2 parsers pars
available forthe following programming languages: (© Tags, Keywords, Categories,
rebtag
© co @ Lists and Outines
© Javascript (server-side and browser) XOXO
© PHP More.
See the Ist ofall microformats
© Python 4 =
© Ruby
© Rust
Upcoming Events
Parsers for various other languages exist, but might not be actively supported or
‘support recent changes to the parsing specication. © See microformats events onthe wik
@ See also IndieWebCamp Events!
There are also various websites which you can use to experiment with
microformats markup without having to download a library and write any code:
(© My own live-updating php-mt2 sandbox Post Categories
(© The various parser comparison tools hosted on microformats.i0 @ Events
© Aaron Pareck'' pin13 net microformats parser for parsing either URLs @ News
or HTML fragments (@ This Week in Microformats
It there's not currently a parser avallable for your language of choice, you have a
few options:
[search blog [=|
© Call the command-tine tools provided by one of the existing libraries
from your code, and consume the JSON they provide
© Make use of one ofthe online m2 parsers capable of parsing sites, and
consume the JSON it returns (only recommended for very low volume
usage!)
© Write your own microformats 2 parser! There are plenty of people
happy to help, and a language-agnostic test suite you can plug your
implementation into for testing
Considerations During Fetching and Parsing
Most real-world microformats data is fetched from a URL, which could potentially
redirect to a different URL one or more times. The final URL in the redirect chain is
called the ‘effective URL’. HTML often contains relative URLs, which need to be
resolved against a base URL in order to be useful out of context.
It your parser has a function for ‘parsing microformats from a URL’, it should deal
with all ofthis for you. If you're making the request yourself (e.g. to use custom
caching or network settings) and then passing the response HTML and base URL
to the parser, make sure to use the effective URL, not the starting URL! The
parser will handle relative URL resolution, but it needs to know the correct base
URL.
When parsing microformats, an HTTP request which retums a non-200 value
doesn't necessarily mean that there's nothing to parse! For example, a 419
Gone response might contain a h-entry with a message explaining the deletion of
whatever was there before.
Storing Raw HTML vs Parsed Canonical JSON
vs Derived Data
When consuming microformats 2 data, you'l most often be fetching raw HTML
from a URL, parsing it to canonical JSON, then finally processing it into a simpler,
cleaned and sanitised format ready for use in your website or application. That's
three different representations of the same data — you'll most likely end up
storing the derived data somewhere for quick access, but what about the other
two?
Experience shows that, over time:
© the way a particular application cleans up mf2 data will be tweaked and
improved as you add new features and handle unexpected edge-cases
© mi2 parsers gradually get improved, fixing bugs and occasionally
‘adding entirely new features
‘Therefore, iit makes sense for your use case, | recommend archiving a copy of
the original HTML as well as your derived data, leaving out the intermediate
canonical JSON. That way, you can easily create scripts or background jobs to
update all the derived data based on the original HTML, taking advantage of both
parser improvements and improvements to your own code at the same time,
without having to re-fetch potentially hundreds of potentially broken links.
‘As mentioned in the previous section, if you archive original HTML for re-parsing,
you'll need to additionally store the effective URL for correct relative URL
resolution.
For some languages, there are already libraries (such as XRay for PHP) which
will perform common cleaning and sanitisation for you. f the assumptions with
Which these libraries are built suit your applications, you may be able to avoid a lot
of the hard work of handling raw microformats 2 data structures!
It not, read on
Navigating Microformat Structures
‘A parsed page may contain a number of microformat data structures (mf structs),
in various different places.
Take a look at the parsed canonical microformats JSON for the article you're
reading right now, for example
items is a list of top-level mf structs, each of which may contain nested mf
structs either under their proper ties or children keys
Each individual mf struct is guaranteed to have at least two keys, type and
properties. type is the primary way of identifying what sort of thing that
struct represents (e.g. a person, a post, an event). Structs can have more than
‘one type if they represent multiple things at once without wanting to nest them —
for example, a post detalling an event might be both a h-entry and a h-event at the
‘same time, Structs can also have additional top-level keys such as id and Lang,
Generally speaking, type information is most useful when dealing with top-evel
mf structs, and mf structs nested under a chi Ldren key. Nested mf structs
found in proper ties will also have type information, but their usage is usually
implied by the property name they're found under.
For many common use cases (@.g. a homepage feed and profile) there are
several different ways people might nest mf structs to achieve the same goals, so
it's important that your code is capable of searching the entire tree, rather than
Just looking at the top-level mf structs. Never assume that the microformat
struct you're looking for will be in the top-level of the i tems list! You need to
‘search the whole tree.
| recommend writing some functions which can traverse a mf tree and return all
structs which match a fitering callback. This can then be used as a basis for
writing more specific convenience functions for common tasks such as finding all
microformats on a page of a particular type, or where a certain property matches
a certain value.
See my microformats2 PHP functions for some working examples.
Possible Property Values
Each key ina mf structs properties dict maps to a lst of values for that
property. Every property may map to multiple values, and those values may be a
mixture of any of the following:
AAplain string value, containing no HTML, and leaving HTML entities unescaped
9.9
{
"items": ({
"type": ["h-card"],
"properties": {
"name": ["Barnaby Walters"]
3
H
z
(in future examples | will leave out the encapsulating {"items": [{"type":
[+++], ***}]} for brevity, focusing on the properties key of a single mt
struct)
‘An embedded HTML struct, containing two keys: htm1, which maps to an HTML
representation of the property, and va Lue, mapping to a plain text version.
"properties": {
"content": [{
"html": "<paThe content of a post, as <strong>raw HTML</strong> (or not).</p>",
"value": "The content of a post, as raw HTML (or not)."
H
z
‘An imgjalt struct, containing the URL of a parsed image under va Lue, and its alt
text under alt
"properties": {
"photo": [{
"value": "https: //example.com/profile-photo. jpg",
"alt": "Example Person"
H
z
Anested microformat data structure, with an additional va Lue key containing a
plaintext representation of the data contained within
"properties": {
"author": [{
"type": ["h-cara"],
"properties": {
"name": ["Barnaby Walters"]
h
"value": "Barnaby Walters
H
z
All properties may have more than one value. In cases where you expect a single
property value (e.g. name), simply take the frst one you find, and in cases where
‘you expect multiple values, use all values you consider valid, There are also some
cases where it may make sense to use multiple values, but to prioritise one based
‘on some heuristic — for example, an h-card may have multiple ur 1 values, in
Which case the first one is usually the “canonical” URL, and further URLs refer to
extemal profiles
Let's look at the implications of each of the potential property value structures in
turn
Firstly, Never assume that a property value will be a plaintext string,
Microformats publishers can nest microformats, embedded content and img/alt
structures in a variety of diferent ways, and your consuming code should be as
flexible as possible.
To partially make up for this complexity, you can always rely on the va lue key
of nested structs to provide you with an equivalent plaintext value,
regardless of what type of struct you've found,
When you start consuming microformats 2, write a function ike this, and get into
the habit of using it every time you want a single, plaintext value from a property:
def get_first_plaintext(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, str):
return first_val
else:
return first_val['value']
except (IndexError, KeyError):
return None
Secondly, Never assume that a particular property will contain an embedded
HTML struct — this usually applies to content, but is relevant anywhere your
application expects embedded HTML. If you want to reliably get a value encoded
‘as raw HTML, then you need to:
1. Check whether the first property value is an embedded HTML struct (Le.
has an htm key). Ifso, take the value of the ht m1 key
2. Othenwise, get the first plaintext property value using the approach above,
and HTML-escape it
3. If neither is found, the property has no value.
In Python 3.5+, that could look something ke this:
from html import escape
def get_first_ntml(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘html’ in first_val:
return first_val[‘html*]
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
plaintext_val = escape(plaintext_val)
return plaintext_val
except (IndexError, KeyError):
return None
In some cases, it may make sense for your application to be aware of whether a
value was parsed as embedded HTML or a plain text string, and to store/treat
them differently. In all other cases, always use a function ike this when you're
‘expecting embedded HTML data.
Thirdly, when expecting an image URL, check for an img/at structure, falling back
to the plain text value (and either assuming an empty alt text or inferring an
appropriate one, depending on your specific use case). Something lke this could
be a good starting point:
def get_img_alt(mf_struct, property name):
try:
first_val = mf_struct[ ‘properties’ ][property_name] [0]
Af isinstance(first_val, dict) and ‘alt’ in first_val:
return first_val
else:
plaintext_val = get_first_plaintext(mf_struct, property_name)
if plaintext_val is not None:
return {'value': plaintext_val, ‘alt': '"}
return None
except (IndexError, KeyError):
return None
Finally, in cases where you expect a nested microformat, you might end up getting
‘something else. This is the hardest case to deal with, and the one which depends
the most on the specific data and use-case you're dealing with. For example, it
you're expecting a nested h-card under an author property, but get something
else, you could use any of the following approaches:
© Ityou got a plain sting which doesn't look like a URL, treat it as the
name property of an implied h-card structure with no other properties
(and if you need a URL, you could potentially take the hostname of the
effective URL, if it works in context as a useful fallback value)
© Ityou got an img at struct, you could treat the va Lue as the photo
property, the at as the name property, and potentially even take the
hostname of the photo URL to be the Implied fallback ur 1 property
(although that's pushing it abit, and in most cases i's probably better to
Just leave out the url)
© Ifyou got an embedded HTML struct, take its plaintext va Lue and use
‘one of the first two approaches
© Ifyou got a plain sting, check to see if itooks ike a URL. Ifso, fetch
that URL and look for a representative h-card to use as the author
value
© Ifyou get an embedded mf struct with a ur l property but no photo,
YyoU could fetch the ur 1, look for a representative h-card (more on that
in the next section) and see ifithhas a photo property
© Treat the author property as invalid and run the h-entry (or entire
page if relevant) through the authorship algorithm
The first three are general principles which can be applied to many scenarios
where you expect an embedded mf struct but find something else, The last three,
however, are examples of a common trend in consuming microformats 2 data: for
many common use-cases, there are well-thought-through algorithms you can use
to interpret data in a standardised way.
Know Your Algorithms and Vocabularies
The authorship algorithm mentioned above is one of several more-or-less formally
established algorithms used to solve common problems in indleweb usages of
microformats 2. Some others which are worth knowing about include:
© “Who wrote this post?": authorship algorithm
(© “There's more than one h-card on this page, which one should | use?”
representative h-card
(© “Iwant to get a paginated feed of posts from this page": How to
consume h-feed
(© “How do | find and display the main post on this page?”: How to
consume h-entry
© “Irecelved a response to one of my posts via webmention, how do |
display it?": How to display comments
Library implementations of these algorithms exist for some languages, although
they often deviate slightly from the exact text. See if you can find one which meets
your needs, and if not, write your own and share it wth the community!
In adaition to the formal consumption algorithms, i's worth looking through the
definitions of the microformats vocabularies you're using (as well as testing with
real-world data) and adding support for properties or publishing techniques you
might not have thought of the first time around. Some examples to get you
started:
© Ian h-card has no valid photo, see if there's a valid Logo you can
use instead
(© When presenting a h-entry with a featured photo, check both the
photo property and the featured property, as one or the other
might be used in different scenarios
© When dealing with address or location data (e.g. on an h-card, h-entry
or h-event), be aware that either might be present in various different
forms. Co-ordinates might be separate Latitude and Longitude
properties, a combined plaintext geo property, or an embedded h-
ge0. Addresses might be separate top-level properties or an
‘embedded h-adr. There are many variations which are totally valid to
publish, and your consuming code should be as liberal as possible in
what it accepts.
© itat-entry contains images which are marked up with u-photo within
the e-content, theyll be present both in the content htm1 key
and also under the photo property. If your app shows the embedded
content HTML rather than using the plaintext version, and also
‘supports photo properties (which may also be present outside the
content), you may have to sniff the presence of photos within the
content, and either remove them from it or ignore the corresponding
photo properties to avoid showing photos twice.
Sanitise, Validate, and Truncate
In the vast majority of cases, consuming microformats 2 data involves handling,
storing and potentially re-publishing untrusted and potentially dangerous input
data, Preventing XSS and other attacks is out of the scope of the microformats
parsing algorithm, so the data your parser gives you is just as dangerous as the
original source. You need to take your own measures for sanitising and truncating
itso you can store and display it safely.
Covering every possible injection and XSS attack is out of the scope of this article,
's0 highly recommend referring to the OWASP resources on XSS Prevention,
Unicode Attacks and Injection Attacks for more information.
Other than that, the following ideas are a good start:
© Use plaintext values where possible, only using embedded HTML when
absolutely necessary
© Pass everything (HTML or not) through a well-respected HTML
sanitizer such as PHP's HTML Purifier. Configure it to make sure that
‘embedded HTML can't interfere with your own markup or CSS. It
probably shouldn't contain any javascript ever, either.
© inany case where you're expecting a value with a specific format,
validate it as appropriate
(© More specifically, everywhere that you expect a URL, check that what
you got was actually a URL. If you're using the URL as an image,
‘consider fetching it an checking its content type
© Consider either proxying resource such as images, or storing local
copies of them (reducing size and resolution as necessary), to avoid
mixed content issues, potential attacks, and missing images ifthe links
break in the futur.
© Decide on relevant maximum length values for each separate piece of
extemal content, and truncate them as necessary. Ideally, use a
language-aware truncation algorithm to avoid breaking words apart.
When the content of a post is truncated, consider adding a "Read More”
link for convenience.
Test with Real-World Data
The web is a diverse place, and microformats are a flexible, permissive method of
marking up structured data. There are often several different yet perfectly valid
ways to achieve the same goal, and as a good consumer of mf2 data, your
application should strive to accept as many of them as possible!
‘The best way to test this is wth real world data. it your application is built with a
particular source of data in mind, then start off with testing it against that. If you
want to be able to handle a wider variety of sources, the best way Is to determine
What vocabularies and publishing use-cases your application consumes, and look
at the Examples sections of the relevant incieweb.org wiki pages for real-world
sites to test your code against.
Don't forget to test your code against examples you've published on your own
personal site!
Next Steps
Hopefully this article helped you avoid a lot of common gotchas, and gave you a
{good head:-start towards successfully consuming real-world microformats 2 data.
Ityou have questions or issues, of want to share something cool you've built,
‘come and join us in the indieweb chat room,
February 19th, 2022 | (FY waterpigs.co.ukd
Comments Off on How to Consume Microformats 2 Data
Google confirms Microformats are still a
recommended metadata format for content
This post originally appeared on Jamie Tanna’s ste
Google announced that they are removing support for the data-vocabulary
metadata markup that could be used to provide rich search results on its Search
Engine,
Ina Twitter exchange, John Mueller, a Webmaster Trends Analyst at Google,
confirmed that Microformats are stil being supported by Google at this time:
Yes, we still support them,
= 3. John Js (@JohnMu) January 24, 2020
John also confirmed that he knows of no upcoming plans to deprecate
Microformats:
We don'thave any plans for changes to announce there at the moment. dant know
off-hand how broadly microformats are used, my guess is i's much more than data
vocabulary. That sad... ips: o/ZCE7TKmPa
= 3. John Js (@JohnMu) January 24, 2020
This is an especially great result due to the way that Google is quite happy to
‘abandon various metadata formats, as noted in our 7th anniversary blog post,
‘almost 8 years ago. With this announcement, Microformats are now the longest-
‘Supported metadata format that Google parses, since at least 2009!
With the continued growth of Microformats across the IndieWeb, we expect that
Google will extend its Microformats support accordingly
Tags for this entry indieweb, microformats2
microformats.org Year 14 — Welcome New Admins
In microformats.org year 14, we welcome new admins: Aaron Parecki, Gregor
Mort, Martijn van der Ven, and Sven Knebel All have been active for years,
helping welcome new members and doing essential wiki gardening &
microformats2 parser updates!
Originally posted at: tantek.com
Tags for this entry microformats2
‘june 22nd, 2018 | {gffrancek
{Comments Off on microformats.org Year 14 — Welcome New Admins
Happy 13th to microformats.org!
With more use of microformats2, especially among the growing indieweb network
of websites, we've iterated key specs for real-world needs and are seeing more
active community members. More updates & posts coming up!
Originally posted on tantek.com.
Tags for this entry indieweb, microformats2
([Btiiex) Comments OF on Happy ao microm oc
Improving the php-mf2 parser
During the past year, the popular php-mt2 microformats parser has received quite
‘a few improvements. My site runs ProcessWire and one of the plugins for it uses
php-mt2, so I have been spending some time on it.
My own experience with microformats started when | discovered the hCard
microformat. Iwas impressed with the novelty of adding some simple HTML
Classes around contact information and having a browser extension parse it into
‘an address book. Years later, when | started to get involved in the IndieWeb
‘community, | leamed a lot more about microformats2 and they became a key
building block of my personal site.
php-mf2 is now much better at backwards-compatible parsing of microformatsi.
This is important because software should be able to consistently consume
content whether i's marked up with microformats1, microformats2, or a
‘combination. An experimental feature for parsing language attributes has also
been added. Finally, i's now using the microformats test suite. Several other
parsers use this test suite as well. This will make it easier to catch bugs and
improve all ofthe different parsers.
php-mt2 is a stable library that's ready to be installed in your software to start
‘consuming microformats.Itis currently used in Known, WordPress plugins, and
ProcessWire plugins for richer social interactions. Is also used in tools ike XRay
and microformats.io. fm looking forward to more improvements to php-mf2 in the
coming year as well as more software using it!
Original published at: hitps:/igregoriove.con/2017/06V/improving-the-php-mi2-
parser!
“dune 22nd, 2017
{Comments Of on Improving the php-mf2 parser
Browse all entries by month in the blog archive
Powered by WordPress | Hosting sponsored by Linode | No WWW.
